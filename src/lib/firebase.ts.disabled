// Firebase/Firestore configuration
import { initializeApp, getApps, FirebaseApp } from 'firebase/app';
import { 
  getFirestore, 
  Firestore,
  collection,
  doc,
  getDoc,
  setDoc,
  updateDoc,
  query,
  where,
  orderBy,
  limit,
  getDocs,
  addDoc,
  serverTimestamp,
  Timestamp,
  onSnapshot,
  DocumentData
} from 'firebase/firestore';
import { 
  getAuth, 
  Auth,
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
  User as FirebaseUser
} from 'firebase/auth';

// Firebase configuration
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID
};

// Initialize Firebase
let app: FirebaseApp;
let db: Firestore;
let auth: Auth;

if (!getApps().length) {
  app = initializeApp(firebaseConfig);
  db = getFirestore(app);
  auth = getAuth(app);
}

export { db, auth };

// Database types (same as Supabase types)
export interface User {
  id: string;
  email: string;
  name?: string;
  subscription_tier: 'free' | 'basic' | 'pro' | 'enterprise';
  created_at: Date | Timestamp;
  updated_at: Date | Timestamp;
}

export interface Subscription {
  id: string;
  user_id: string;
  stripe_subscription_id?: string;
  status: 'active' | 'inactive' | 'canceled' | 'past_due';
  current_period_start?: Date | Timestamp;
  current_period_end?: Date | Timestamp;
  created_at: Date | Timestamp;
}

export interface UsageStat {
  id: string;
  user_id: string;
  discussion_count: number;
  topic: string;
  agents: string[];
  thinking_mode: string;
  success: boolean;
  response_time: number;
  ai_provider: string;
  created_at: Date | Timestamp;
}

export interface Discussion {
  id: string;
  user_id: string;
  topic: string;
  agents: string[];
  thinking_mode: string;
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  result?: string;
  created_at: Date | Timestamp;
  updated_at: Date | Timestamp;
}

// Database helper functions (Firebase/Firestore implementation)
export class FirestoreService {
  // Check if Firebase is configured
  private static isConfigured(): boolean {
    return !!firebaseConfig.apiKey && firebaseConfig.apiKey !== 'your-api-key';
  }

  // User management
  static async createUser(userData: {
    email: string;
    name?: string;
    password?: string;
    subscription_tier?: 'free' | 'basic' | 'pro' | 'enterprise';
  }): Promise<User> {
    if (!this.isConfigured()) {
      throw new Error('Firebase is not configured');
    }

    let userId = '';
    
    // Create auth user if password provided
    if (userData.password) {
      const userCredential = await createUserWithEmailAndPassword(auth, userData.email, userData.password);
      userId = userCredential.user.uid;
    }

    // Create user document in Firestore
    const user: User = {
      id: userId,
      email: userData.email,
      name: userData.name,
      subscription_tier: userData.subscription_tier || 'free',
      created_at: serverTimestamp(),
      updated_at: serverTimestamp()
    };

    await setDoc(doc(db, 'users', userId), user);
    return user;
  }

  static async getUserById(userId: string): Promise<User | null> {
    if (!this.isConfigured()) {
      return null;
    }

    const userDoc = await getDoc(doc(db, 'users', userId));
    
    if (!userDoc.exists()) {
      return null;
    }

    return userDoc.data() as User;
  }

  static async updateUserTier(userId: string, tier: 'free' | 'basic' | 'pro' | 'enterprise'): Promise<void> {
    if (!this.isConfigured()) {
      return;
    }

    await updateDoc(doc(db, 'users', userId), {
      subscription_tier: tier,
      updated_at: serverTimestamp()
    });
  }

  // Subscription management
  static async createSubscription(subscriptionData: {
    user_id: string;
    stripe_subscription_id?: string;
    status: 'active' | 'inactive' | 'canceled' | 'past_due';
    current_period_start?: Date;
    current_period_end?: Date;
  }): Promise<Subscription> {
    if (!this.isConfigured()) {
      throw new Error('Firebase is not configured');
    }

    const subscription = {
      ...subscriptionData,
      created_at: serverTimestamp()
    };

    const docRef = await addDoc(collection(db, 'subscriptions'), subscription);
    
    return {
      id: docRef.id,
      ...subscription,
      created_at: new Date()
    } as Subscription;
  }

  static async getActiveSubscription(userId: string): Promise<Subscription | null> {
    if (!this.isConfigured()) {
      return null;
    }

    const q = query(
      collection(db, 'subscriptions'),
      where('user_id', '==', userId),
      where('status', '==', 'active'),
      limit(1)
    );

    const querySnapshot = await getDocs(q);
    
    if (querySnapshot.empty) {
      return null;
    }

    const doc = querySnapshot.docs[0];
    return {
      id: doc.id,
      ...doc.data()
    } as Subscription;
  }

  static async updateSubscriptionStatus(
    subscriptionId: string, 
    status: 'active' | 'inactive' | 'canceled' | 'past_due'
  ): Promise<void> {
    if (!this.isConfigured()) {
      return;
    }

    // Find subscription by stripe_subscription_id
    const q = query(
      collection(db, 'subscriptions'),
      where('stripe_subscription_id', '==', subscriptionId),
      limit(1)
    );

    const querySnapshot = await getDocs(q);
    
    if (!querySnapshot.empty) {
      const doc = querySnapshot.docs[0];
      await updateDoc(doc.ref, { status });
    }
  }

  // Usage tracking
  static async recordDiscussion(usageData: {
    user_id: string;
    topic: string;
    agents: string[];
    thinking_mode: string;
    success: boolean;
    response_time: number;
    ai_provider: string;
  }): Promise<UsageStat> {
    if (!this.isConfigured()) {
      throw new Error('Firebase is not configured');
    }

    const usage = {
      ...usageData,
      discussion_count: 1,
      created_at: serverTimestamp()
    };

    const docRef = await addDoc(collection(db, 'usage_stats'), usage);
    
    return {
      id: docRef.id,
      ...usage,
      created_at: new Date()
    } as UsageStat;
  }

  static async getMonthlyUsage(userId: string): Promise<number> {
    if (!this.isConfigured()) {
      return 0;
    }

    const startOfMonth = new Date();
    startOfMonth.setDate(1);
    startOfMonth.setHours(0, 0, 0, 0);

    const q = query(
      collection(db, 'usage_stats'),
      where('user_id', '==', userId),
      where('created_at', '>=', startOfMonth)
    );

    const querySnapshot = await getDocs(q);
    
    let totalUsage = 0;
    querySnapshot.forEach((doc) => {
      const data = doc.data();
      totalUsage += data.discussion_count || 1;
    });

    return totalUsage;
  }

  static async getDailyUsage(userId: string): Promise<number> {
    if (!this.isConfigured()) {
      return 0;
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const q = query(
      collection(db, 'usage_stats'),
      where('user_id', '==', userId),
      where('created_at', '>=', today),
      where('created_at', '<', tomorrow)
    );

    const querySnapshot = await getDocs(q);
    
    let totalUsage = 0;
    querySnapshot.forEach((doc) => {
      const data = doc.data();
      totalUsage += data.discussion_count || 1;
    });

    return totalUsage;
  }

  static async getUserUsageHistory(
    userId: string, 
    limit: number = 50
  ): Promise<UsageStat[]> {
    if (!this.isConfigured()) {
      return [];
    }

    const q = query(
      collection(db, 'usage_stats'),
      where('user_id', '==', userId),
      orderBy('created_at', 'desc'),
      limit(limit)
    );

    const querySnapshot = await getDocs(q);
    
    const usage: UsageStat[] = [];
    querySnapshot.forEach((doc) => {
      usage.push({
        id: doc.id,
        ...doc.data()
      } as UsageStat);
    });

    return usage;
  }

  // Discussion management
  static async saveDiscussion(discussionData: {
    user_id: string;
    topic: string;
    agents: string[];
    thinking_mode: string;
    result?: string;
    status?: 'pending' | 'in_progress' | 'completed' | 'failed';
  }): Promise<Discussion> {
    if (!this.isConfigured()) {
      throw new Error('Firebase is not configured');
    }

    const discussion = {
      ...discussionData,
      status: discussionData.status || 'completed',
      created_at: serverTimestamp(),
      updated_at: serverTimestamp()
    };

    const docRef = await addDoc(collection(db, 'discussions'), discussion);
    
    return {
      id: docRef.id,
      ...discussion,
      created_at: new Date(),
      updated_at: new Date()
    } as Discussion;
  }

  static async getDiscussionHistory(
    userId: string, 
    limit: number = 20
  ): Promise<Discussion[]> {
    if (!this.isConfigured()) {
      return [];
    }

    const q = query(
      collection(db, 'discussions'),
      where('user_id', '==', userId),
      orderBy('created_at', 'desc'),
      limit(limit)
    );

    const querySnapshot = await getDocs(q);
    
    const discussions: Discussion[] = [];
    querySnapshot.forEach((doc) => {
      discussions.push({
        id: doc.id,
        ...doc.data()
      } as Discussion);
    });

    return discussions;
  }

  static async updateDiscussionStatus(
    discussionId: string, 
    status: 'pending' | 'in_progress' | 'completed' | 'failed',
    result?: string
  ): Promise<void> {
    if (!this.isConfigured()) {
      return;
    }

    const updateData: any = { 
      status, 
      updated_at: serverTimestamp()
    };
    
    if (result) {
      updateData.result = result;
    }

    await updateDoc(doc(db, 'discussions', discussionId), updateData);
  }

  // Analytics and reporting
  static async getUserAnalytics(userId: string): Promise<{
    totalDiscussions: number;
    monthlyDiscussions: number;
    successRate: number;
    averageResponseTime: number;
    topAgents: string[];
    topModes: string[];
  }> {
    if (!this.isConfigured()) {
      return {
        totalDiscussions: 0,
        monthlyDiscussions: 0,
        successRate: 0,
        averageResponseTime: 0,
        topAgents: [],
        topModes: []
      };
    }

    // Get all user stats
    const allStats = await this.getUserUsageHistory(userId, 1000);
    const monthlyStats = await this.getMonthlyUsage(userId);

    const totalDiscussions = allStats.length;
    const successfulDiscussions = allStats.filter(stat => stat.success).length;
    const successRate = totalDiscussions > 0 ? (successfulDiscussions / totalDiscussions) * 100 : 0;
    const averageResponseTime = allStats.reduce((sum, stat) => sum + stat.response_time, 0) / (allStats.length || 1);

    // Calculate top agents and modes
    const agentCount: Record<string, number> = {};
    const modeCount: Record<string, number> = {};

    allStats.forEach(stat => {
      stat.agents?.forEach(agent => {
        agentCount[agent] = (agentCount[agent] || 0) + 1;
      });
      modeCount[stat.thinking_mode] = (modeCount[stat.thinking_mode] || 0) + 1;
    });

    const topAgents = Object.entries(agentCount)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 3)
      .map(([agent]) => agent);

    const topModes = Object.entries(modeCount)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 3)
      .map(([mode]) => mode);

    return {
      totalDiscussions,
      monthlyDiscussions: monthlyStats,
      successRate,
      averageResponseTime,
      topAgents,
      topModes
    };
  }
}

// Real-time subscriptions using Firestore
export const subscribeToUserChanges = (userId: string, callback: (data: DocumentData) => void) => {
  if (!firebaseConfig.apiKey || firebaseConfig.apiKey === 'your-api-key') {
    console.warn('Firebase not configured, skipping user changes subscription');
    return {
      unsubscribe: () => {}
    };
  }

  const unsubscribe = onSnapshot(doc(db, 'users', userId), (doc) => {
    if (doc.exists()) {
      callback(doc.data());
    }
  });

  return { unsubscribe };
};

export const subscribeToUsageUpdates = (userId: string, callback: (data: DocumentData) => void) => {
  if (!firebaseConfig.apiKey || firebaseConfig.apiKey === 'your-api-key') {
    console.warn('Firebase not configured, skipping usage updates subscription');
    return {
      unsubscribe: () => {}
    };
  }

  const q = query(
    collection(db, 'usage_stats'),
    where('user_id', '==', userId),
    orderBy('created_at', 'desc'),
    limit(1)
  );

  const unsubscribe = onSnapshot(q, (querySnapshot) => {
    querySnapshot.docChanges().forEach((change) => {
      if (change.type === 'added') {
        callback(change.doc.data());
      }
    });
  });

  return { unsubscribe };
};

// Auth helper functions
export const signInUser = async (email: string, password: string) => {
  return signInWithEmailAndPassword(auth, email, password);
};

export const signOutUser = async () => {
  return signOut(auth);
};

export const onAuthChange = (callback: (user: FirebaseUser | null) => void) => {
  return onAuthStateChanged(auth, callback);
};